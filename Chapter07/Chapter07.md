# 07장 | 어댑터 패턴과 퍼사드 패턴

## 어댑터 패턴(Adapter Pattern)

- 기존에 사용하던 인터페이스와 새로운 인터페이스를 연결시켜주는 클래스가 어댑터입니다.
- 어댑터 패턴은 특정 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환합니다.
  - => 이를 통해, 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 해 줍니다.

### 클라이언트에서 어댑터를 사용하는 방법

1. 클라이언트에서 타깃 인터페이스로 메소드를 호출해서 어댑터에 요청을 보냅니다.
2. 어댑터는 어댑티 인터페이스로 그 요청을 어댑티에 관한 (하나 이상의) 메소드 호출로 변환합니다.
3. 클라이언트는 호출 결과를 받긴 하지만 중간에 어댑터가 있다는 사실을 모릅니다. -> 클라이언트와 어댑터는 서로 분리되어 있기 때문에 서로를 전혀 알 수 없습니다!

### 어댑터 패턴의 특징

- 여러 객체지향 원칙을 반영한다:

  - 어댑터 패턴은 객체지향의 중요한 원칙들을 따릅니다. 여기에는 **단일 책임 원칙(Single Responsibility Principle)** 과 **개방-폐쇄 원칙(Open/Closed Principle)** 등이 포함됩니다.
  - 단일 책임 원칙: 어댑터는 변환 작업만을 담당합니다.
  - 개방-폐쇄 원칙: 어댑터를 추가하는 것만으로 기존 코드를 수정하지 않고도 새로운 인터페이스와 호환되게 만들 수 있습니다.

- 객체 구성(composition)을 사용한다:

  - 객체 구성은 객체지향 설계에서 다른 객체를 포함(구성)하여 기능을 확장하거나 변경하는 방법입니다. 상속과는 달리 구성은 런타임에 다른 객체를 참조함으로써 동작을 변경할 수 있습니다.
  - 어댑터 패턴에서는 '어댑티'라는 기존 클래스의 객체를 어댑터 클래스 내부에 포함시켜(구성) 이를 새 인터페이스에 맞게 변환합니다.

- 어댑티의 모든 서브클래스에 어댑터를 쓸 수 있다는 장점:

  - 어댑티(기존 클래스)를 어댑터로 감싸게 되면, 어댑티의 서브클래스(하위 클래스)들도 어댑터를 통해 새로운 인터페이스를 사용할 수 있습니다. 이는 코드의 재사용성을 높이고 유연성을 제공합니다.

- 클라이언트를 특정 구현이 아닌 인터페이스에 연결한다:
  - 어댑터 패턴의 핵심은 클라이언트가 특정 클래스의 구체적인 구현(details)에 의존하지 않도록 만드는 것입니다. 대신 클라이언트는 인터페이스(interface)에 의존하게 됩니다. 이렇게 하면 다양한 구현체를 쉽게 교체하거나 확장할 수 있습니다.

## 퍼사드 패턴(Facade Pattern)

- 인터페이스를 단순하게 바꾸기 위한 퍼사드 패턴
  - 퍼사드(facade)는 겉모양이나 외관이라는 뜻입니다.
- 기존의 인터페이스보다 사용하기 편리한 퍼사드 클래스를 구현하면 복잡한 시스템을 훨씬 편리하게 사용할 수 있습니다.
- 퍼사드 클래스는 서브시스템의 기능을 사용할 수 있는 간단한 인터페이스를 제공하는 것 뿐입니다.
- 클라이언트에서 특정 인터페이스가 필요하다면 서브시스템 클래스를 그냥 사용하면 됩니다.
  - => 퍼사드 클래스는 단순화된 인터페이스를 제공하면서도, 클라이언트에서 필요로 한다면 시스템의 모든 기능을 사용할 수 있도록 해줍니다.
- 퍼사드 패턴은 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶어줍니다. 또한, 고수준 인터페이스도 정의하므로 서븝ㅂ시스템을 더 편리하게 사용할 수 있습니다.

### 퍼사드 패턴을 사용하는 자바 API 예시

- 자바 컬렉션 프레임워크는 다양한 데이터 구조를 제공하는데, 이 프레임워크 자체가 퍼사드 패턴의 예로 볼 수 있습니다.
- 컬렉션을 편리하게 사용할 수 있게 하도록 Collections 클래스가 제공하는 정적 메서드들이 퍼사드 패턴의 좋은 예입니다.
- 예시 코드

  ```java
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.List;

  public class CollectionsFacadeExample {
      public static void main(String[] args) {
          List<String> list = new ArrayList<>();
          list.add("Apple");
          list.add("Banana");
          list.add("Cherry");

          // Sorting the list
          Collections.sort(list);
          System.out.println("Sorted List: " + list);

          // Reversing the list
          Collections.reverse(list);
          System.out.println("Reversed List: " + list);
      }
  }

  ```

  - 이와 같이 Collections 클래스는 복잡한 연산을 간단한 메서드 호출로 대체하여, 사용자가 컬렉션을 쉽게 다룰 수 있도록 합니다. 이는 퍼사드 패턴의 핵심 개념과 일치합니다.

## 최소 지식 원칙(Principle of Least Knowledge)

- 시스템을 디자인할 때 어떤 객체든 그 객체와 상호작용을 하는 클래스의 개수와 상호작용의 방식에 주의를 기울여야 합니다.
- 이 원칠을 잘 따르면 여러 클래스가 복잡하게 얽혀 있어서, 시스템의 한 부분을 변경했을 때 다른 부분까지 줄줄이 고쳐야 하는 상황을 미리 방지할 수 있습니다.
  - 여러 클래스가 서로 복잡하게 의존하고 있다면 관리하기도 힘들고, 남들이 이해하기도 어려운 불안정한 시스템이 만들어집니다.
- 데메테르의 법칙과 최소 지식 원칙은 완전히 똑같은 용어이다.
