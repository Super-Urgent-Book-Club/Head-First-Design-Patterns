# 01장 | 디자인 패턴 소개와 전략 패턴

## 상속을 생각하기

- 슈퍼클래스 Duck이 있을 때, 서브클래스에서 이 클래스의 행동을 상속할 때 단점이 될 수 있는 요소
  - 서브클래스에서 코드가 중복된다.
  - 실행 시에 특징을 바꾸기 힘들다. 별도로 오버라이드 해줘야 하기 때문이다.
  - 모든 서브클래스의 행동을 알기 힘들다.
  - 코드를 변경했을 때 다른 서브클래스들에게 원치 않은 영향을 끼칠 수 있다.

## 인터페이스 설계하기

- 어떤 클래스가 계속 바뀐다면, 상속을 계속 활용할 경우...
  > Duck의 서브클래스 fly()와 quack() 메소드를 일일이 살펴보고 상황에 따라 오버라이드해야함. 매.번.
- 따라서, 특정 형식의 오리(서브클래스)만 날거나 꽥꽥거릴 수 있도록 하는 식의 더 깔끔한 방법이 필요하다.

### 디자인 원칙

1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.

- <=> "바뀌는 부분은 따로 뽑아서 캡슐화한다. 그러면 나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다."
- 이 개념은 모든 디자인 패턴의 기반을 이루는 원칙이다.
- 모든 패턴은 '시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있는' 방법을 제공하니까!
  <br><br>

2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다.

- 이 말의 뜻은, 상위 형식에 맞춰서 코딩한다는 뜻이다.

  - 예시 코드

    - Animal 이라는 추상 클래스와, 그 밑에 Dog, Cat이라는 구상 클래스가 있을 때

    ```java
    // 구현에 맞춰서 프로그래밍한 경우
    Dog d = new Dog();
    d.bark();

    // 인터페이스와 상위 형식에 맞춰서 프로그래밍한 경우
    Animal animal = new Dog();
    animal.makeSound();

    // 더 바람직한 방식; 구현된 객체 대입하기
    a = getAnimal();
    a.makeSound(); // 여기서 a가 정확히 어떤 형식의 객체인지는 안 중요함. makeSound는 모든 동물 객체에서 실행할 수 있다는 것만 중요함.
    ```

# 첫 번째 디자인 패턴: 전략 패턴

전략 패턴은 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다. 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.
